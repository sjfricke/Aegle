{"metadata":{"usedHelpers":["classCallCheck","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"./local_collection.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"LocalCollection"}]}],"exports":{"exported":["Cursor"],"specifiers":[{"kind":"local","local":"Cursor","exported":"default"}]}}},"options":{"filename":"packages/minimongo/cursor.js","filenameRelative":"packages/minimongo/cursor.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/minimongo/cursor.js.map","sourceFileName":"packages/minimongo/cursor.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"cursor"},"ignored":false,"code":"var _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nmodule.export({\n  \"default\": function () {\n    return Cursor;\n  }\n});\nvar LocalCollection = void 0;\nmodule.watch(require(\"./local_collection.js\"), {\n  \"default\": function (v) {\n    LocalCollection = v;\n  }\n}, 0);\n\nvar Cursor = function () {\n  // don't call this ctor directly.  use LocalCollection.find().\n  function Cursor(collection, selector) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0, _classCallCheck3.default)(this, Cursor);\n    this.collection = collection;\n    this.sorter = null;\n    this.matcher = new Minimongo.Matcher(selector);\n\n    if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n      // stash for fast _id and { _id }\n      this._selectorId = selector._id || selector;\n    } else {\n      this._selectorId = undefined;\n\n      if (this.matcher.hasGeoQuery() || options.sort) {\n        this.sorter = new Minimongo.Sorter(options.sort || [], {\n          matcher: this.matcher\n        });\n      }\n    }\n\n    this.skip = options.skip || 0;\n    this.limit = options.limit;\n    this.fields = options.fields;\n    this._projectionFn = LocalCollection._compileProjection(this.fields || {});\n    this._transform = LocalCollection.wrapTransform(options.transform); // by default, queries register w/ Tracker when it is available.\n\n    if (typeof Tracker !== 'undefined') {\n      this.reactive = options.reactive === undefined ? true : options.reactive;\n    }\n  } /**\n     * @summary Returns the number of documents that match a query.\n     * @memberOf Mongo.Cursor\n     * @method  count\n     * @instance\n     * @locus Anywhere\n     * @returns {Number}\n     */\n\n  Cursor.prototype.count = function () {\n    function count() {\n      if (this.reactive) {\n        // allow the observe to be unordered\n        this._depend({\n          added: true,\n          removed: true\n        }, true);\n      }\n\n      return this._getRawObjects({\n        ordered: true\n      }).length;\n    }\n\n    return count;\n  }(); /**\n        * @summary Return all matching documents as an Array.\n        * @memberOf Mongo.Cursor\n        * @method  fetch\n        * @instance\n        * @locus Anywhere\n        * @returns {Object[]}\n        */\n\n  Cursor.prototype.fetch = function () {\n    function fetch() {\n      var result = [];\n      this.forEach(function (doc) {\n        result.push(doc);\n      });\n      return result;\n    }\n\n    return fetch;\n  }(); /**\n        * @callback IterationCallback\n        * @param {Object} doc\n        * @param {Number} index\n        */ /**\n            * @summary Call `callback` once for each matching document, sequentially and\n            *          synchronously.\n            * @locus Anywhere\n            * @method  forEach\n            * @instance\n            * @memberOf Mongo.Cursor\n            * @param {IterationCallback} callback Function to call. It will be called\n            *                                     with three arguments: the document, a\n            *                                     0-based index, and <em>cursor</em>\n            *                                     itself.\n            * @param {Any} [thisArg] An object which will be the value of `this` inside\n            *                        `callback`.\n            */\n\n  Cursor.prototype.forEach = function () {\n    function forEach(callback, thisArg) {\n      var _this = this;\n\n      if (this.reactive) {\n        this._depend({\n          addedBefore: true,\n          removed: true,\n          changed: true,\n          movedBefore: true\n        });\n      }\n\n      this._getRawObjects({\n        ordered: true\n      }).forEach(function (element, i) {\n        // This doubles as a clone operation.\n        element = _this._projectionFn(element);\n\n        if (_this._transform) {\n          element = _this._transform(element);\n        }\n\n        callback.call(thisArg, element, i, _this);\n      });\n    }\n\n    return forEach;\n  }();\n\n  Cursor.prototype.getTransform = function () {\n    function getTransform() {\n      return this._transform;\n    }\n\n    return getTransform;\n  }(); /**\n        * @summary Map callback over all matching documents.  Returns an Array.\n        * @locus Anywhere\n        * @method map\n        * @instance\n        * @memberOf Mongo.Cursor\n        * @param {IterationCallback} callback Function to call. It will be called\n        *                                     with three arguments: the document, a\n        *                                     0-based index, and <em>cursor</em>\n        *                                     itself.\n        * @param {Any} [thisArg] An object which will be the value of `this` inside\n        *                        `callback`.\n        */\n\n  Cursor.prototype.map = function () {\n    function map(callback, thisArg) {\n      var _this2 = this;\n\n      var result = [];\n      this.forEach(function (doc, i) {\n        result.push(callback.call(thisArg, doc, i, _this2));\n      });\n      return result;\n    }\n\n    return map;\n  }(); // options to contain:\n  //  * callbacks for observe():\n  //    - addedAt (document, atIndex)\n  //    - added (document)\n  //    - changedAt (newDocument, oldDocument, atIndex)\n  //    - changed (newDocument, oldDocument)\n  //    - removedAt (document, atIndex)\n  //    - removed (document)\n  //    - movedTo (document, oldIndex, newIndex)\n  //\n  // attributes available on returned query handle:\n  //  * stop(): end updates\n  //  * collection: the collection this query is querying\n  //\n  // iff x is a returned query handle, (x instanceof\n  // LocalCollection.ObserveHandle) is true\n  //\n  // initial results delivered through added callback\n  // XXX maybe callbacks should take a list of objects, to expose transactions?\n  // XXX maybe support field limiting (to limit what you're notified on)\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n\n  Cursor.prototype.observe = function () {\n    function observe(options) {\n      return LocalCollection._observeFromObserveChanges(this, options);\n    }\n\n    return observe;\n  }(); /**\n        * @summary Watch a query. Receive callbacks as the result set changes. Only\n        *          the differences between the old and new documents are passed to\n        *          the callbacks.\n        * @locus Anywhere\n        * @memberOf Mongo.Cursor\n        * @instance\n        * @param {Object} callbacks Functions to call to deliver the result set as it\n        *                           changes\n        */\n\n  Cursor.prototype.observeChanges = function () {\n    function observeChanges(options) {\n      var _this3 = this;\n\n      var ordered = LocalCollection._observeChangesCallbacksAreOrdered(options); // there are several places that assume you aren't combining skip/limit with\n      // unordered observe.  eg, update's EJSON.clone, and the \"there are several\"\n      // comment in _modifyAndNotify\n      // XXX allow skip/limit with unordered observe\n\n\n      if (!options._allow_unordered && !ordered && (this.skip || this.limit)) {\n        throw new Error('must use ordered observe (ie, \\'addedBefore\\' instead of \\'added\\') ' + 'with skip or limit');\n      }\n\n      if (this.fields && (this.fields._id === 0 || this.fields._id === false)) {\n        throw Error('You may not observe a cursor with {fields: {_id: 0}}');\n      }\n\n      var distances = this.matcher.hasGeoQuery() && ordered && new LocalCollection._IdMap();\n      var query = {\n        cursor: this,\n        dirty: false,\n        distances: distances,\n        matcher: this.matcher,\n        // not fast pathed\n        ordered: ordered,\n        projectionFn: this._projectionFn,\n        resultsSnapshot: null,\n        sorter: ordered && this.sorter\n      };\n      var qid = void 0; // Non-reactive queries call added[Before] and then never call anything\n      // else.\n\n      if (this.reactive) {\n        qid = this.collection.next_qid++;\n        this.collection.queries[qid] = query;\n      }\n\n      query.results = this._getRawObjects({\n        ordered: ordered,\n        distances: query.distances\n      });\n\n      if (this.collection.paused) {\n        query.resultsSnapshot = ordered ? [] : new LocalCollection._IdMap();\n      } // wrap callbacks we were passed. callbacks only fire when not paused and\n      // are never undefined\n      // Filters out blacklisted fields according to cursor's projection.\n      // XXX wrong place for this?\n      // furthermore, callbacks enqueue until the operation we're working on is\n      // done.\n\n\n      var wrapCallback = function (fn) {\n        if (!fn) {\n          return function () {};\n        }\n\n        var self = _this3;\n        return function () /* args*/{\n          var _this4 = this;\n\n          if (self.collection.paused) {\n            return;\n          }\n\n          var args = arguments;\n\n          self.collection._observeQueue.queueTask(function () {\n            fn.apply(_this4, args);\n          });\n        };\n      };\n\n      query.added = wrapCallback(options.added);\n      query.changed = wrapCallback(options.changed);\n      query.removed = wrapCallback(options.removed);\n\n      if (ordered) {\n        query.addedBefore = wrapCallback(options.addedBefore);\n        query.movedBefore = wrapCallback(options.movedBefore);\n      }\n\n      if (!options._suppress_initial && !this.collection.paused) {\n        var results = ordered ? query.results : query.results._map;\n        Object.keys(results).forEach(function (key) {\n          var doc = results[key];\n          var fields = EJSON.clone(doc);\n          delete fields._id;\n\n          if (ordered) {\n            query.addedBefore(doc._id, _this3._projectionFn(fields), null);\n          }\n\n          query.added(doc._id, _this3._projectionFn(fields));\n        });\n      }\n\n      var handle = Object.assign(new LocalCollection.ObserveHandle(), {\n        collection: this.collection,\n        stop: function () {\n          if (_this3.reactive) {\n            delete _this3.collection.queries[qid];\n          }\n        }\n      });\n\n      if (this.reactive && Tracker.active) {\n        // XXX in many cases, the same observe will be recreated when\n        // the current autorun is rerun.  we could save work by\n        // letting it linger across rerun and potentially get\n        // repurposed if the same observe is performed, using logic\n        // similar to that of Meteor.subscribe.\n        Tracker.onInvalidate(function () {\n          handle.stop();\n        });\n      } // run the observe callbacks resulting from the initial contents\n      // before we leave the observe.\n\n\n      this.collection._observeQueue.drain();\n\n      return handle;\n    }\n\n    return observeChanges;\n  }(); // Since we don't actually have a \"nextObject\" interface, there's really no\n  // reason to have a \"rewind\" interface.  All it did was make multiple calls\n  // to fetch/map/forEach return nothing the second time.\n  // XXX COMPAT WITH 0.8.1\n\n\n  Cursor.prototype.rewind = function () {\n    function rewind() {}\n\n    return rewind;\n  }(); // XXX Maybe we need a version of observe that just calls a callback if\n  // anything changed.\n\n\n  Cursor.prototype._depend = function () {\n    function _depend(changers, _allow_unordered) {\n      if (Tracker.active) {\n        var dependency = new Tracker.Dependency();\n        var notify = dependency.changed.bind(dependency);\n        dependency.depend();\n        var options = {\n          _allow_unordered: _allow_unordered,\n          _suppress_initial: true\n        };\n        ['added', 'addedBefore', 'changed', 'movedBefore', 'removed'].forEach(function (fn) {\n          if (changers[fn]) {\n            options[fn] = notify;\n          }\n        }); // observeChanges will stop() when this computation is invalidated\n\n        this.observeChanges(options);\n      }\n    }\n\n    return _depend;\n  }();\n\n  Cursor.prototype._getCollectionName = function () {\n    function _getCollectionName() {\n      return this.collection.name;\n    }\n\n    return _getCollectionName;\n  }(); // Returns a collection of matching objects, but doesn't deep copy them.\n  //\n  // If ordered is set, returns a sorted array, respecting sorter, skip, and\n  // limit properties of the query.  if sorter is falsey, no sort -- you get the\n  // natural order.\n  //\n  // If ordered is not set, returns an object mapping from ID to doc (sorter,\n  // skip and limit should not be set).\n  //\n  // If ordered is set and this cursor is a $near geoquery, then this function\n  // will use an _IdMap to track each distance from the $near argument point in\n  // order to use it as a sort key. If an _IdMap is passed in the 'distances'\n  // argument, this function will clear it and use it for this purpose\n  // (otherwise it will just create its own _IdMap). The observeChanges\n  // implementation uses this to remember the distances after this function\n  // returns.\n\n\n  Cursor.prototype._getRawObjects = function () {\n    function _getRawObjects() {\n      var _this5 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // XXX use OrderedDict instead of array, and make IdMap and OrderedDict\n      // compatible\n      var results = options.ordered ? [] : new LocalCollection._IdMap(); // fast path for single ID value\n\n      if (this._selectorId !== undefined) {\n        // If you have non-zero skip and ask for a single id, you get\n        // nothing. This is so it matches the behavior of the '{_id: foo}'\n        // path.\n        if (this.skip) {\n          return results;\n        }\n\n        var selectedDoc = this.collection._docs.get(this._selectorId);\n\n        if (selectedDoc) {\n          if (options.ordered) {\n            results.push(selectedDoc);\n          } else {\n            results.set(this._selectorId, selectedDoc);\n          }\n        }\n\n        return results;\n      } // slow path for arbitrary selector, sort, skip, limit\n      // in the observeChanges case, distances is actually part of the \"query\"\n      // (ie, live results set) object.  in other cases, distances is only used\n      // inside this function.\n\n\n      var distances = void 0;\n\n      if (this.matcher.hasGeoQuery() && options.ordered) {\n        if (options.distances) {\n          distances = options.distances;\n          distances.clear();\n        } else {\n          distances = new LocalCollection._IdMap();\n        }\n      }\n\n      this.collection._docs.forEach(function (doc, id) {\n        var matchResult = _this5.matcher.documentMatches(doc);\n\n        if (matchResult.result) {\n          if (options.ordered) {\n            results.push(doc);\n\n            if (distances && matchResult.distance !== undefined) {\n              distances.set(id, matchResult.distance);\n            }\n          } else {\n            results.set(id, doc);\n          }\n        } // Fast path for limited unsorted queries.\n        // XXX 'length' check here seems wrong for ordered\n\n\n        return !_this5.limit || _this5.skip || _this5.sorter || results.length !== _this5.limit;\n      });\n\n      if (!options.ordered) {\n        return results;\n      }\n\n      if (this.sorter) {\n        results.sort(this.sorter.getComparator({\n          distances: distances\n        }));\n      }\n\n      if (!this.limit && !this.skip) {\n        return results;\n      }\n\n      return results.slice(this.skip, this.limit ? this.limit + this.skip : results.length);\n    }\n\n    return _getRawObjects;\n  }();\n\n  Cursor.prototype._publishCursor = function () {\n    function _publishCursor(subscription) {\n      // XXX minimongo should not depend on mongo-livedata!\n      if (!Package.mongo) {\n        throw new Error('Can\\'t publish from Minimongo without the `mongo` package.');\n      }\n\n      if (!this.collection.name) {\n        throw new Error('Can\\'t publish a cursor from a collection without a name.');\n      }\n\n      return Package.mongo.Mongo.Collection._publishCursor(this, subscription, this.collection.name);\n    }\n\n    return _publishCursor;\n  }();\n\n  return Cursor;\n}();","map":{"version":3,"sources":["packages/minimongo/cursor.js"],"names":["module","export","Cursor","LocalCollection","watch","require","v","collection","selector","options","sorter","matcher","Minimongo","Matcher","_selectorIsIdPerhapsAsObject","_selectorId","_id","undefined","hasGeoQuery","sort","Sorter","skip","limit","fields","_projectionFn","_compileProjection","_transform","wrapTransform","transform","Tracker","reactive","count","_depend","added","removed","_getRawObjects","ordered","length","fetch","result","forEach","push","doc","callback","thisArg","addedBefore","changed","movedBefore","element","i","call","getTransform","map","observe","_observeFromObserveChanges","observeChanges","_observeChangesCallbacksAreOrdered","_allow_unordered","Error","distances","_IdMap","query","cursor","dirty","projectionFn","resultsSnapshot","qid","next_qid","queries","results","paused","wrapCallback","fn","self","args","arguments","_observeQueue","queueTask","apply","_suppress_initial","_map","Object","keys","key","EJSON","clone","handle","assign","ObserveHandle","stop","active","onInvalidate","drain","rewind","changers","dependency","Dependency","notify","bind","depend","_getCollectionName","name","selectedDoc","_docs","get","set","clear","id","matchResult","documentMatches","distance","getComparator","slice","_publishCursor","subscription","Package","mongo","Mongo","Collection"],"mappings":"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","file":"packages/minimongo/cursor.js.map","sourcesContent":["import LocalCollection from './local_collection.js';\n\n// Cursor: a specification for a particular subset of documents, w/ a defined\n// order, limit, and offset.  creating a Cursor with LocalCollection.find(),\nexport default class Cursor {\n  // don't call this ctor directly.  use LocalCollection.find().\n  constructor(collection, selector, options = {}) {\n    this.collection = collection;\n    this.sorter = null;\n    this.matcher = new Minimongo.Matcher(selector);\n\n    if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n      // stash for fast _id and { _id }\n      this._selectorId = selector._id || selector;\n    } else {\n      this._selectorId = undefined;\n\n      if (this.matcher.hasGeoQuery() || options.sort) {\n        this.sorter = new Minimongo.Sorter(\n          options.sort || [],\n          {matcher: this.matcher}\n        );\n      }\n    }\n\n    this.skip = options.skip || 0;\n    this.limit = options.limit;\n    this.fields = options.fields;\n\n    this._projectionFn = LocalCollection._compileProjection(this.fields || {});\n\n    this._transform = LocalCollection.wrapTransform(options.transform);\n\n    // by default, queries register w/ Tracker when it is available.\n    if (typeof Tracker !== 'undefined') {\n      this.reactive = options.reactive === undefined ? true : options.reactive;\n    }\n  }\n\n  /**\n   * @summary Returns the number of documents that match a query.\n   * @memberOf Mongo.Cursor\n   * @method  count\n   * @instance\n   * @locus Anywhere\n   * @returns {Number}\n   */\n  count() {\n    if (this.reactive) {\n      // allow the observe to be unordered\n      this._depend({added: true, removed: true}, true);\n    }\n\n    return this._getRawObjects({ordered: true}).length;\n  }\n\n  /**\n   * @summary Return all matching documents as an Array.\n   * @memberOf Mongo.Cursor\n   * @method  fetch\n   * @instance\n   * @locus Anywhere\n   * @returns {Object[]}\n   */\n  fetch() {\n    const result = [];\n\n    this.forEach(doc => {\n      result.push(doc);\n    });\n\n    return result;\n  }\n\n  /**\n   * @callback IterationCallback\n   * @param {Object} doc\n   * @param {Number} index\n   */\n  /**\n   * @summary Call `callback` once for each matching document, sequentially and\n   *          synchronously.\n   * @locus Anywhere\n   * @method  forEach\n   * @instance\n   * @memberOf Mongo.Cursor\n   * @param {IterationCallback} callback Function to call. It will be called\n   *                                     with three arguments: the document, a\n   *                                     0-based index, and <em>cursor</em>\n   *                                     itself.\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\n   *                        `callback`.\n   */\n  forEach(callback, thisArg) {\n    if (this.reactive) {\n      this._depend({\n        addedBefore: true,\n        removed: true,\n        changed: true,\n        movedBefore: true});\n    }\n\n    this._getRawObjects({ordered: true}).forEach((element, i) => {\n      // This doubles as a clone operation.\n      element = this._projectionFn(element);\n\n      if (this._transform) {\n        element = this._transform(element);\n      }\n\n      callback.call(thisArg, element, i, this);\n    });\n  }\n\n  getTransform() {\n    return this._transform;\n  }\n\n  /**\n   * @summary Map callback over all matching documents.  Returns an Array.\n   * @locus Anywhere\n   * @method map\n   * @instance\n   * @memberOf Mongo.Cursor\n   * @param {IterationCallback} callback Function to call. It will be called\n   *                                     with three arguments: the document, a\n   *                                     0-based index, and <em>cursor</em>\n   *                                     itself.\n   * @param {Any} [thisArg] An object which will be the value of `this` inside\n   *                        `callback`.\n   */\n  map(callback, thisArg) {\n    const result = [];\n\n    this.forEach((doc, i) => {\n      result.push(callback.call(thisArg, doc, i, this));\n    });\n\n    return result;\n  }\n\n  // options to contain:\n  //  * callbacks for observe():\n  //    - addedAt (document, atIndex)\n  //    - added (document)\n  //    - changedAt (newDocument, oldDocument, atIndex)\n  //    - changed (newDocument, oldDocument)\n  //    - removedAt (document, atIndex)\n  //    - removed (document)\n  //    - movedTo (document, oldIndex, newIndex)\n  //\n  // attributes available on returned query handle:\n  //  * stop(): end updates\n  //  * collection: the collection this query is querying\n  //\n  // iff x is a returned query handle, (x instanceof\n  // LocalCollection.ObserveHandle) is true\n  //\n  // initial results delivered through added callback\n  // XXX maybe callbacks should take a list of objects, to expose transactions?\n  // XXX maybe support field limiting (to limit what you're notified on)\n\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n  observe(options) {\n    return LocalCollection._observeFromObserveChanges(this, options);\n  }\n\n  /**\n   * @summary Watch a query. Receive callbacks as the result set changes. Only\n   *          the differences between the old and new documents are passed to\n   *          the callbacks.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it\n   *                           changes\n   */\n  observeChanges(options) {\n    const ordered = LocalCollection._observeChangesCallbacksAreOrdered(options);\n\n    // there are several places that assume you aren't combining skip/limit with\n    // unordered observe.  eg, update's EJSON.clone, and the \"there are several\"\n    // comment in _modifyAndNotify\n    // XXX allow skip/limit with unordered observe\n    if (!options._allow_unordered && !ordered && (this.skip || this.limit)) {\n      throw new Error(\n        'must use ordered observe (ie, \\'addedBefore\\' instead of \\'added\\') ' +\n        'with skip or limit'\n      );\n    }\n\n    if (this.fields && (this.fields._id === 0 || this.fields._id === false)) {\n      throw Error('You may not observe a cursor with {fields: {_id: 0}}');\n    }\n\n    const distances = (\n      this.matcher.hasGeoQuery() &&\n      ordered &&\n      new LocalCollection._IdMap\n    );\n\n    const query = {\n      cursor: this,\n      dirty: false,\n      distances,\n      matcher: this.matcher, // not fast pathed\n      ordered,\n      projectionFn: this._projectionFn,\n      resultsSnapshot: null,\n      sorter: ordered && this.sorter\n    };\n\n    let qid;\n\n    // Non-reactive queries call added[Before] and then never call anything\n    // else.\n    if (this.reactive) {\n      qid = this.collection.next_qid++;\n      this.collection.queries[qid] = query;\n    }\n\n    query.results = this._getRawObjects({ordered, distances: query.distances});\n\n    if (this.collection.paused) {\n      query.resultsSnapshot = ordered ? [] : new LocalCollection._IdMap;\n    }\n\n    // wrap callbacks we were passed. callbacks only fire when not paused and\n    // are never undefined\n    // Filters out blacklisted fields according to cursor's projection.\n    // XXX wrong place for this?\n\n    // furthermore, callbacks enqueue until the operation we're working on is\n    // done.\n    const wrapCallback = fn => {\n      if (!fn) {\n        return () => {};\n      }\n\n      const self = this;\n      return function(/* args*/) {\n        if (self.collection.paused) {\n          return;\n        }\n\n        const args = arguments;\n\n        self.collection._observeQueue.queueTask(() => {\n          fn.apply(this, args);\n        });\n      };\n    };\n\n    query.added = wrapCallback(options.added);\n    query.changed = wrapCallback(options.changed);\n    query.removed = wrapCallback(options.removed);\n\n    if (ordered) {\n      query.addedBefore = wrapCallback(options.addedBefore);\n      query.movedBefore = wrapCallback(options.movedBefore);\n    }\n\n    if (!options._suppress_initial && !this.collection.paused) {\n      const results = ordered ? query.results : query.results._map;\n\n      Object.keys(results).forEach(key => {\n        const doc = results[key];\n        const fields = EJSON.clone(doc);\n\n        delete fields._id;\n\n        if (ordered) {\n          query.addedBefore(doc._id, this._projectionFn(fields), null);\n        }\n\n        query.added(doc._id, this._projectionFn(fields));\n      });\n    }\n\n    const handle = Object.assign(new LocalCollection.ObserveHandle, {\n      collection: this.collection,\n      stop: () => {\n        if (this.reactive) {\n          delete this.collection.queries[qid];\n        }\n      }\n    });\n\n    if (this.reactive && Tracker.active) {\n      // XXX in many cases, the same observe will be recreated when\n      // the current autorun is rerun.  we could save work by\n      // letting it linger across rerun and potentially get\n      // repurposed if the same observe is performed, using logic\n      // similar to that of Meteor.subscribe.\n      Tracker.onInvalidate(() => {\n        handle.stop();\n      });\n    }\n\n    // run the observe callbacks resulting from the initial contents\n    // before we leave the observe.\n    this.collection._observeQueue.drain();\n\n    return handle;\n  }\n\n  // Since we don't actually have a \"nextObject\" interface, there's really no\n  // reason to have a \"rewind\" interface.  All it did was make multiple calls\n  // to fetch/map/forEach return nothing the second time.\n  // XXX COMPAT WITH 0.8.1\n  rewind() {}\n\n  // XXX Maybe we need a version of observe that just calls a callback if\n  // anything changed.\n  _depend(changers, _allow_unordered) {\n    if (Tracker.active) {\n      const dependency = new Tracker.Dependency;\n      const notify = dependency.changed.bind(dependency);\n\n      dependency.depend();\n\n      const options = {_allow_unordered, _suppress_initial: true};\n\n      ['added', 'addedBefore', 'changed', 'movedBefore', 'removed']\n        .forEach(fn => {\n          if (changers[fn]) {\n            options[fn] = notify;\n          }\n        });\n\n      // observeChanges will stop() when this computation is invalidated\n      this.observeChanges(options);\n    }\n  }\n\n  _getCollectionName() {\n    return this.collection.name;\n  }\n\n  // Returns a collection of matching objects, but doesn't deep copy them.\n  //\n  // If ordered is set, returns a sorted array, respecting sorter, skip, and\n  // limit properties of the query.  if sorter is falsey, no sort -- you get the\n  // natural order.\n  //\n  // If ordered is not set, returns an object mapping from ID to doc (sorter,\n  // skip and limit should not be set).\n  //\n  // If ordered is set and this cursor is a $near geoquery, then this function\n  // will use an _IdMap to track each distance from the $near argument point in\n  // order to use it as a sort key. If an _IdMap is passed in the 'distances'\n  // argument, this function will clear it and use it for this purpose\n  // (otherwise it will just create its own _IdMap). The observeChanges\n  // implementation uses this to remember the distances after this function\n  // returns.\n  _getRawObjects(options = {}) {\n    // XXX use OrderedDict instead of array, and make IdMap and OrderedDict\n    // compatible\n    const results = options.ordered ? [] : new LocalCollection._IdMap;\n\n    // fast path for single ID value\n    if (this._selectorId !== undefined) {\n      // If you have non-zero skip and ask for a single id, you get\n      // nothing. This is so it matches the behavior of the '{_id: foo}'\n      // path.\n      if (this.skip) {\n        return results;\n      }\n\n      const selectedDoc = this.collection._docs.get(this._selectorId);\n\n      if (selectedDoc) {\n        if (options.ordered) {\n          results.push(selectedDoc);\n        } else {\n          results.set(this._selectorId, selectedDoc);\n        }\n      }\n\n      return results;\n    }\n\n    // slow path for arbitrary selector, sort, skip, limit\n\n    // in the observeChanges case, distances is actually part of the \"query\"\n    // (ie, live results set) object.  in other cases, distances is only used\n    // inside this function.\n    let distances;\n    if (this.matcher.hasGeoQuery() && options.ordered) {\n      if (options.distances) {\n        distances = options.distances;\n        distances.clear();\n      } else {\n        distances = new LocalCollection._IdMap();\n      }\n    }\n\n    this.collection._docs.forEach((doc, id) => {\n      const matchResult = this.matcher.documentMatches(doc);\n\n      if (matchResult.result) {\n        if (options.ordered) {\n          results.push(doc);\n\n          if (distances && matchResult.distance !== undefined) {\n            distances.set(id, matchResult.distance);\n          }\n        } else {\n          results.set(id, doc);\n        }\n      }\n\n      // Fast path for limited unsorted queries.\n      // XXX 'length' check here seems wrong for ordered\n      return (\n        !this.limit ||\n        this.skip ||\n        this.sorter ||\n        results.length !== this.limit\n      );\n    });\n\n    if (!options.ordered) {\n      return results;\n    }\n\n    if (this.sorter) {\n      results.sort(this.sorter.getComparator({distances}));\n    }\n\n    if (!this.limit && !this.skip) {\n      return results;\n    }\n\n    return results.slice(\n      this.skip,\n      this.limit ? this.limit + this.skip : results.length\n    );\n  }\n\n  _publishCursor(subscription) {\n    // XXX minimongo should not depend on mongo-livedata!\n    if (!Package.mongo) {\n      throw new Error(\n        'Can\\'t publish from Minimongo without the `mongo` package.'\n      );\n    }\n\n    if (!this.collection.name) {\n      throw new Error(\n        'Can\\'t publish a cursor from a collection without a name.'\n      );\n    }\n\n    return Package.mongo.Mongo.Collection._publishCursor(\n      this,\n      subscription,\n      this.collection.name\n    );\n  }\n}\n"]},"hash":"2aeca0de8fce230e7ca7e367660f0b26c89b112d"}
